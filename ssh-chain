#!/usr/bin/perl -w
use strict;

use IPC::Open3;

my $host_arg = $ARGV[0] || die "No host passed!";
my $port_arg = $ARGV[1] || die "No port passed!";

my $FORCE_NETCAT = $ENV{'FORCE_NETCAT'} || 0;
my $SSH_BIN = $ENV{'SSH_BIN'} || 'ssh';
my $DEBUG   = $ENV{'DEBUG'}   || 0;

my ($dest_host, $bounce_host);
if ($host_arg =~ /\A([^\^]+)\^([^\^].*)/) {
  ($dest_host, $bounce_host) = ($1, $2);
} else {
  die "Invalid arguments!";
}

# Deal with usernames
$bounce_host =~ s/\A([^\^\+]+)\+/$1\@/;
# Strip username+ syntax from the dest host
$dest_host =~ s/\A.*\+//;

if ($dest_host =~ /\A([^\^]+)_(\d+)\z/) {
  $dest_host = $1;
  $port_arg  = $2;
}

print STDERR "Connecting to $dest_host:$port_arg via $bounce_host\n" if ($DEBUG);

if (ssh_has_W()) {
  ssh_bounce_native($dest_host, $port_arg, $bounce_host);
} else {
  ssh_bounce_netcat($dest_host, $port_arg, $bounce_host);
}

# Shouldn't make it this far
exit 1;

# See if the local version of ssh supports -W ('netcat mode')
sub ssh_has_W {
  my $ret = 0;
  return $ret if ($FORCE_NETCAT);
  my $pid = open3(undef, undef, \*FH, $SSH_BIN);
  while(my $line = <FH>) {
    if ($line =~ /\[-W\s/) {
      while (<FH>) {}; # Consume the rest of the output so ssh exits cleanly
      $ret = 1;
    }
  }
  close(FH);
  waitpid($pid, 0);
  return $ret;
}

sub ssh_bounce_native {
  my $dest_host   = shift;
  my $port_arg    = shift;
  my $bounce_host = shift;

  print STDERR "Using ssh -W\n" if ($DEBUG);
  ssh_bounce_generic($dest_host, $port_arg, $bounce_host, [$SSH_BIN, '-W', "$dest_host:$port_arg"]);
}

sub ssh_bounce_netcat {
  my $dest_host   = shift;
  my $port_arg    = shift;
  my $bounce_host = shift;

  print STDERR "Using ssh exec netcat\n" if ($DEBUG);
  ssh_bounce_generic($dest_host, $port_arg, $bounce_host, [$SSH_BIN], ['exec', 'nc', $dest_host, $port_arg]);
}

sub ssh_bounce_generic {
  my $dest_host   = shift;
  my $port_arg    = shift;
  my $bounce_host = shift;
  my $local_cmd   = shift || []; # needs an arrayref
  my $remote_cmd  = shift || []; # needs an arrayref

  my @SSH_CMD = @$local_cmd; # dereference
  if ($bounce_host =~ /\A([^\^]+)_(\d+)\z/) {
    $bounce_host = $1;
    push(@SSH_CMD, '-p', $2);
  }
  # reduce key warnings and known_hosts pollution by correcting ssh's idea of
  # what target host should be used when matching known fingerprints. This does
  # not prevent the whole initial caretpath from being logged/checked, though
  # that can be prevented by specifying -o Hostname=... yourself
  if ($bounce_host =~ /\A(?:[^\+\@]+[\@\+])?([A-Za-z0-9_\-\.]+)(?:_\d+)?\^/) {
    push(@SSH_CMD, '-o', "Hostname=$1");
  }
  push(@SSH_CMD, $bounce_host);
  push(@SSH_CMD, @$remote_cmd);
  print STDERR join(' ', @SSH_CMD) . "\n" if ($DEBUG);
  exec(@SSH_CMD); # Script stops here
}
# vim: ts=2 sw=2 et ai si
